# 특정한 최단경로
https://www.acmicpc.net/problem/1504
# 주의
1. 문제는 두 정점 F, T를 포함해야 된다함. 1->F->T->V, 말고 1->T->F->V도 생각했었어야함
2. 문제에서 F !=V, T !=1 부분을 꼼꼼하게 안읽음. 
결국 둘다 문제를 꼼꼼하게 안읽어서 틀림. 문제의 조건을 유심히 파악..

```python
import sys
import heapq

def dijkstra2(fr):    
    
    mixheap = []
    for i in range(1,V+1):    
        distance[i] = INF
    distance[fr] = 0

    for i in graph[fr]:
        heapq.heappush(mixheap,[i[1], i[0]] )
        distance[i[0]] = i[1] + distance[fr]
        # 최소힙에 (weight i[1],  to_node i[0]) 형태로 추가 
    while len(mixheap) >0 :
        weight, node = heapq.heappop(mixheap)    
        if weight >= distance[node]:
            continue
        for i in graph[node]:
            if i[1] + distance[node] < distance[i[0]]:
                # weight + distance[fr] < distance[to]
                distance[i[0]] = i[1] + distance[node]
                heapq.heappush(mixheap,[i[1], i[0]])    
    

V, E = map(int,sys.stdin.readline().split())
distance={}
graph = {}
INF = sys.maxsize
for i in range(1,V+1):
    graph[i] = []
    
for i in range(E):
    v1, v2, weight = map(int, sys.stdin.readline().split())
    graph[v1].append([v2,weight])
    graph[v2].append([v1,weight])
m_f, m_t = map(int, sys.stdin.readline().split())
result = INF
flag1, flag2 = 0,0
dijkstra2(1)
one_to_To = distance[m_t]
one_to_From = distance[m_f]
dijkstra2(m_f)
From_to_To = distance[m_t]
From_to_V = distance[V]
dijkstra2(m_t)
To_to_V = distance[V]
result1 = one_to_From + From_to_To + To_to_V
result2 = one_to_To + From_to_To + From_to_V

if result1 >= INF and result2 >= INF:
    print(-1)
else:
    print(min(result1, result2))

```

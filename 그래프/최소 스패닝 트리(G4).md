# Minimum Spanning Tree
https://www.acmicpc.net/problem/1197

## 1. Kruskal ALgorithm
1. 우선순위 큐를 활용해 가중치값이 작은 순서대로 간선을 꺼낸다.
2. 꺼낸 간선을 이용해 그래프를 만든다.
3. 만약, 순환그래프를 형성하면 해당 간선은 버린다.
+ 모든 간선을 다 꺼낼때까지 위 과정을 반복한다. 

[순환그래프인지 확인하는방법]   
https://github.com/TedLeem/Algorithm-Self-Study/blob/main/%EC%8B%A0%EA%B8%B0%EB%B0%A9%EA%B8%B0/ways%20to%20check%20cyclic.md

### 주의
__'크루스칼 알고리즘의 순환그래프 확인 여부도 프림알고리즘 처럼 visited배열을 통해 둘다 방문했던 노드라면 순환그래프라고 판단하면 되지않는가?'__  라는 의문이 들었었는데 다음 반례가 있다.
#### > A-B 그래프와 C-D 그래프를 연결하는 간선이 힙에서 꺼내었을때
#### 순환그래프인지 확인하는 알고리즘의 이름이 괜히 'Disjoint set Union'이 아니다. 
서로 다른 그래프를 합쳐야 하므로 크루스칼 알고리즘과 다르게  
프림 알고리즘은 하나의 그래프에서 해당 노드의 모든 연결된 간선을 추가해나가므로 위처럼 고려할 필요 없이 단순 방문노드여부 확인으로만 구현이 가능하다.

## 코드1 (틀림)
```python
import sys
import heapq
import copy
class Edge:
    def __init__(self,vertex_from, vertex_to , weight) -> None:
        self.vertex_from = vertex_from
        self.vertex_to = vertex_to
        self.weight = weight
    def __lt__(self, other):
        return self.weight <= other.weight

class Vertex:
    def __init__(self, vertex):
        self.name = vertex
        self.neighbors = []
        # (노드이름 , 간선가중치)
        

    def add_neighbor(self, neighbor, weight):
        if isinstance(neighbor, Vertex):
            if neighbor.name not in self.neighbors:
                self.neighbors.append((neighbor.name,weight))
                neighbor.neighbors.append((self.name,weight))
                
                #self.neighbors = sorted(self.neighbors) //정렬해줘야하나?
                #neighbor.neighbors = sorted(neighbor.neighbors)
        else:
            return False
        
    def add_neighbors(self, neighbors):
        for neighbor in neighbors:
            self.add_neighbor(self,neighbor[0],neighbor[1])
            
        
    def __repr__(self):
        return str(self.neighbors)


class Graph:
    def __init__(self):
        self.vertices = {}
        self.parent = {}
    
    def add_vertex(self, vertex):
        if isinstance(vertex, Vertex):
            self.vertices[vertex.name] = vertex.neighbors

            
    def add_vertices(self, vertices):
        for vertex in vertices:
            if isinstance(vertex, Vertex):
                self.vertices[vertex.name] = vertex.neighbors
            
    def add_edge(self, vertex_from, vertex_to,weight ):
            
        vertex_f = Vertex(vertex_from)
        vertex_t = Vertex(vertex_to)
        
        vertex_f.add_neighbor(vertex_t,weight)
        # tempVertices = copy.deepcopy(self.vertices)
        # tempParent = self.parent
        #임시데이터저장

        if self.is_cycle(vertex_f.name, vertex_t.name):
            return False
        else:
            if isinstance(vertex_f, Vertex) and isinstance(vertex_t, Vertex):
                if len(self.vertices.keys()) > 0 and vertex_f.name in self.vertices.keys() :
                    # self.vertices[vertex_f.name].append(vertex_f.neighbors)
                    # python list append(list) -> append list as a element in the list
                    # we have to use + or extend 
                    self.vertices[vertex_f.name].extend(vertex_f.neighbors)
                    # 이미존재하는 vertex라면 이어붙여주기 
                else:                
                    self.vertices[vertex_f.name] = vertex_f.neighbors                
                    
                    # 처음 추가하는 vertex라면 초기화해주기
                if len(self.vertices.keys()) > 0 and vertex_t.name in self.vertices.keys() :
                    self.vertices[vertex_t.name].extend( vertex_t.neighbors)
                else:
                    self.vertices[vertex_t.name] = vertex_t.neighbors
                            
        return True

    def add_edges(self, edges):
        for edge in edges:
            self.add_edge(edge[0],edge[1])  

    def find(self, vertex_name):
        while self.parent[vertex_name]!= vertex_name:
            # 자기자신의 이름을 저장하고있다. -> 루트노드임
            vertex_name = self.parent[vertex_name]
        return vertex_name
    

    def is_cycle(self, vertex_from_name, vertex_to_name):
        
        if len(self.vertices.keys()) > 0 and vertex_from_name in self.vertices.keys():
        # 기존에 있는 Vertex라면
            root_from = self.find(vertex_from_name)
        else:
            self.parent[vertex_from_name] = vertex_from_name
            root_from = vertex_from_name
        
        if len(self.vertices.keys()) > 0 and vertex_to_name in self.vertices.keys():        
            root_to = self.find(vertex_to_name)
        else:
            self.parent[vertex_to_name] = vertex_to_name
            root_to = vertex_to_name
        if root_from != root_to:
            # union할 집합의 부모가 루트노드가 다르다면 합쳐도 순환하지않음을 의미
            self.parent[vertex_to_name] = root_from
            return False
        else:
            return True

    def __repr__(self):
         
        if len(self.vertices) >= 1:
                ls = [str(key) + ":" + str(self.vertices[key]) for key in self.vertices.keys()]  
        else:
            ls = dict()
        return ls

    

V,E = map(int,sys.stdin.readline().split())
graph = Graph()
heap = []  #힙으로 만들 리스트 녀썩

for i in range(E):
    vertex_from , vertex_to, weight = map(int,sys.stdin.readline().split())
    edge = Edge(vertex_from, vertex_to, weight)
    heapq.heappush(heap,(edge.weight, edge))  
#     # heappush(힙으로만들리스트, (priority, item) )

mst = 0
for i in range(len(heap)):
    edge = heapq.heappop(heap)[1] # (가중치, Edge) 반환
    if graph.add_edge(edge.vertex_from,edge.vertex_to,edge.weight):
    #  잘 추가되었으면 해당간선의 가중치를 추가 
        mst += edge.weight 

print(mst)
```
## 2. Prim's Algorithm
프림 알고리즘의 원리는 다음과 같은 MST의 의미로부터 나올 수 있다.   
'그래프의 모든 노드를 한 번 씩 연결하는~'  
### 즉, MST의 각 노드는 최소 한 번 가장 가중치값이 작은 간선으로 다른 노드와 연결되어 있다.  
### 해당 노드가 어떤 노드와 몇개의 간선과 연결되어있어도 반드시 해당 간선중에서는 가장 작은 가중치 값을 가지는 간선 최소 하나가 존재한다.
### 그래서 노드에 대해 모든 간선을 생각한 뒤 최소 값만 mst에 추가해나가는 방식이다. 

### 주의
#### From 노드와 To 노드를 구분하는게 구현하기 편하다.

### 1. Lazy Version
### 2. Eager Version

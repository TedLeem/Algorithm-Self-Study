# Minimum Spanning Tree
https://www.acmicpc.net/problem/1197

## 1. Kruskal ALgorithm
1. 우선순위 큐를 활용해 가중치값이 작은 순서대로 간선을 꺼낸다.
2. 꺼낸 간선을 이용해 그래프를 만든다.
3. 만약, 순환그래프를 형성하면 해당 간선은 버린다.
+ 모든 간선을 다 꺼낼때까지 위 과정을 반복한다. 

[순환그래프인지 확인하는방법]   
https://github.com/TedLeem/Algorithm-Self-Study/blob/main/%EC%8B%A0%EA%B8%B0%EB%B0%A9%EA%B8%B0/ways%20to%20check%20cyclic.md

## 코드1 (틀림)
```python
import sys
import heapq
import copy
class Edge:
    def __init__(self,vertex_from, vertex_to , weight) -> None:
        self.vertex_from = vertex_from
        self.vertex_to = vertex_to
        self.weight = weight
    def __lt__(self, other):
        return self.weight <= other.weight

class Vertex:
    def __init__(self, vertex):
        self.name = vertex
        self.neighbors = []
        # (노드이름 , 간선가중치)
        

    def add_neighbor(self, neighbor, weight):
        if isinstance(neighbor, Vertex):
            if neighbor.name not in self.neighbors:
                self.neighbors.append((neighbor.name,weight))
                neighbor.neighbors.append((self.name,weight))
                
                #self.neighbors = sorted(self.neighbors) //정렬해줘야하나?
                #neighbor.neighbors = sorted(neighbor.neighbors)
        else:
            return False
        
    def add_neighbors(self, neighbors):
        for neighbor in neighbors:
            self.add_neighbor(self,neighbor[0],neighbor[1])
            
        
    def __repr__(self):
        return str(self.neighbors)


class Graph:
    def __init__(self):
        self.vertices = {}
        self.parent = {}
    
    def add_vertex(self, vertex):
        if isinstance(vertex, Vertex):
            self.vertices[vertex.name] = vertex.neighbors

            
    def add_vertices(self, vertices):
        for vertex in vertices:
            if isinstance(vertex, Vertex):
                self.vertices[vertex.name] = vertex.neighbors
            
    def add_edge(self, vertex_from, vertex_to,weight ):
            
        vertex_f = Vertex(vertex_from)
        vertex_t = Vertex(vertex_to)
        
        vertex_f.add_neighbor(vertex_t,weight)
        # tempVertices = copy.deepcopy(self.vertices)
        # tempParent = self.parent
        #임시데이터저장

        if self.is_cycle(vertex_f.name, vertex_t.name):
            return False
        else:
            if isinstance(vertex_f, Vertex) and isinstance(vertex_t, Vertex):
                if len(self.vertices.keys()) > 0 and vertex_f.name in self.vertices.keys() :
                    # self.vertices[vertex_f.name].append(vertex_f.neighbors)
                    # python list append(list) -> append list as a element in the list
                    # we have to use + or extend 
                    self.vertices[vertex_f.name].extend(vertex_f.neighbors)
                    # 이미존재하는 vertex라면 이어붙여주기 
                else:                
                    self.vertices[vertex_f.name] = vertex_f.neighbors                
                    
                    # 처음 추가하는 vertex라면 초기화해주기
                if len(self.vertices.keys()) > 0 and vertex_t.name in self.vertices.keys() :
                    self.vertices[vertex_t.name].extend( vertex_t.neighbors)
                else:
                    self.vertices[vertex_t.name] = vertex_t.neighbors
                            
        return True

    def add_edges(self, edges):
        for edge in edges:
            self.add_edge(edge[0],edge[1])  

    def find(self, vertex_name):
        while self.parent[vertex_name]!= vertex_name:
            # 자기자신의 이름을 저장하고있다. -> 루트노드임
            vertex_name = self.parent[vertex_name]
        return vertex_name
    

    def is_cycle(self, vertex_from_name, vertex_to_name):
        
        if len(self.vertices.keys()) > 0 and vertex_from_name in self.vertices.keys():
        # 기존에 있는 Vertex라면
            root_from = self.find(vertex_from_name)
        else:
            self.parent[vertex_from_name] = vertex_from_name
            root_from = vertex_from_name
        
        if len(self.vertices.keys()) > 0 and vertex_to_name in self.vertices.keys():        
            root_to = self.find(vertex_to_name)
        else:
            self.parent[vertex_to_name] = vertex_to_name
            root_to = vertex_to_name
        if root_from != root_to:
            # union할 집합의 부모가 루트노드가 다르다면 합쳐도 순환하지않음을 의미
            self.parent[vertex_to_name] = root_from
            return False
        else:
            return True

    def __repr__(self):
         
        if len(self.vertices) >= 1:
                ls = [str(key) + ":" + str(self.vertices[key]) for key in self.vertices.keys()]  
        else:
            ls = dict()
        return ls

    

V,E = map(int,sys.stdin.readline().split())
graph = Graph()
heap = []  #힙으로 만들 리스트 녀썩

for i in range(E):
    vertex_from , vertex_to, weight = map(int,sys.stdin.readline().split())
    edge = Edge(vertex_from, vertex_to, weight)
    heapq.heappush(heap,(edge.weight, edge))  
#     # heappush(힙으로만들리스트, (priority, item) )

mst = 0
for i in range(len(heap)):
    edge = heapq.heappop(heap)[1] # (가중치, Edge) 반환
    if graph.add_edge(edge.vertex_from,edge.vertex_to,edge.weight):
    #  잘 추가되었으면 해당간선의 가중치를 추가 
        mst += edge.weight 

print(mst)
```
## 2. Prim's Algorithm

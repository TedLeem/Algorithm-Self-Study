# Minimum Spanning Tree
https://www.acmicpc.net/problem/1197


## 1. Kruskal ALgorithm
1. 우선순위 큐를 활용해 가중치값이 작은 순서대로 간선을 꺼낸다.
2. 꺼낸 간선을 이용해 그래프를 만든다.
3. 만약, 순환그래프를 형성하면 해당 간선은 버린다.
+ 모든 간선을 다 꺼낼때까지 위 과정을 반복한다. 

[순환그래프인지 확인하는방법]   
https://github.com/TedLeem/Algorithm-Self-Study/blob/main/%EC%8B%A0%EA%B8%B0%EB%B0%A9%EA%B8%B0/ways%20to%20check%20cyclic.md

### 주의
__'크루스칼 알고리즘의 순환그래프 확인 여부도 프림알고리즘 처럼 visited배열을 통해 둘다 방문했던 노드라면 순환그래프라고 판단하면 되지않는가?'__  라는 의문이 들었었는데 다음 반례가 있다.
#### > A-B 그래프와 C-D 그래프를 연결하는 간선이 힙에서 꺼내었을때
#### 순환그래프인지 확인하는 알고리즘의 이름이 괜히 'Disjoint set Union'이 아니다. 
서로 다른 그래프를 합쳐야 하므로 크루스칼 알고리즘과 다르게  
프림 알고리즘은 하나의 그래프에서 해당 노드의 모든 연결된 간선을 추가해나가므로 위처럼 고려할 필요 없이 단순 방문노드여부 확인으로만 구현이 가능하다.

## 코드
```python
import sys
import heapq
class Edge:
    def __init__(self,vertex_from, vertex_to , weight) -> None:
        self.vertex_from = vertex_from
        self.vertex_to = vertex_to
        self.weight = weight
    def __lt__(self, other):
        return self.weight <= other.weight

class Vertex:
    def __init__(self, vertex):
        self.name = vertex
        self.neighbors = []
        # (노드이름 , 간선가중치)
        

    def add_neighbor(self, neighbor, weight):
        if isinstance(neighbor, Vertex):
            if neighbor.name not in self.neighbors:
                self.neighbors.append((neighbor.name,weight))
                neighbor.neighbors.append((self.name,weight))            
        else:
            return False

class Graph:
    def __init__(self):
        self.vertices = {}
        self.parent = {}
        self.mstEdge =0
    
    def add_vertex(self, vertex):
        if isinstance(vertex, Vertex):
            self.vertices[vertex.name] = vertex.neighbors
            
    def add_edge(self, vertex_from, vertex_to,weight ):
            
        vertex_f = Vertex(vertex_from)
        vertex_t = Vertex(vertex_to)
        
        vertex_f.add_neighbor(vertex_t,weight)

        if self.is_cycle(vertex_f.name, vertex_t.name):
            return False
        else:
            
            if len(self.vertices.keys()) > 0 and vertex_f.name in self.vertices.keys() :                
                self.vertices[vertex_f.name].extend(vertex_f.neighbors)
                # 이미 존재하는 vertex라면 이어붙여주기 
            else:                
                self.vertices[vertex_f.name] = vertex_f.neighbors                                
                # 처음 추가하는 vertex라면 초기화해주기
            if len(self.vertices.keys()) > 0 and vertex_t.name in self.vertices.keys() :
                self.vertices[vertex_t.name].extend( vertex_t.neighbors)
            else:
                self.vertices[vertex_t.name] = vertex_t.neighbors
                        
        return True

    def find(self, vertex_name):
        if self.parent[vertex_name]!= vertex_name:
            return self.find(self.parent[vertex_name])
        else:
            return self.parent[vertex_name]
    

    def is_cycle(self, vertex_from_name, vertex_to_name):
        
        root_from = self.find(vertex_from_name)
        root_to = self.find(vertex_to_name)
        
        if root_from != root_to:
            # union할 집합의 부모가 루트노드가 다르다면 합쳐도 순환하지않음을 의미
            if root_from > root_to:
                self.parent[root_from] = root_to
            else:
                self.parent[root_to] = root_from
            return False
        else:
            return True

V,E = map(int,sys.stdin.readline().split())
graph = Graph()
heap = []  #힙으로 만들 리스트 녀썩
mst = 0
edgeLs = []
if E >= V-1:
    for i in range(E):
        vertex_from , vertex_to, weight = map(int,sys.stdin.readline().split())
        edge = Edge(vertex_from, vertex_to, weight)
        heapq.heappush(heap,(edge.weight, edge))  
    #     # heappush(힙으로만들리스트, (priority, item) )
        graph.parent[vertex_from] = edge.vertex_from
        graph.parent[vertex_to] = edge.vertex_to
    
    for i in range(len(heap)):
        edge = heapq.heappop(heap)[1] # (가중치, Edge) 반환
        
        if graph.add_edge(edge.vertex_from,edge.vertex_to,edge.weight):
        #  잘 추가되었으면 해당간선의 가중치를 추가 
            mst += edge.weight 
            graph.mstEdge +=1

if graph.mstEdge == V-1:
    print(mst)
else:
    print(0)

```
## 2. Prim's Algorithm
### 1. Lazy Version
프림 알고리즘의 원리는 다음과 같은 MST의 의미로부터 나올 수 있다.   
'그래프의 모든 노드를 한 번 씩 연결하는~'  
### 즉, MST의 각 노드는 반드시 하나 이상의 다른 노드와 연결되어 있다.
### 해당 노드가 어떤 노드와 몇개의 간선으로 연결되어있어도 반드시 해당 간선중에는 가장 작은 가중치 값을 가지는 간선 최소 하나가 존재한다.
### 그래서 해당 노드와 연결된 모든 간선을 pq에 넣은 뒤 최소 값만 mst에 추가해나가는 방식이다. 

### 주의
#### From 노드와 To 노드를 구분하는게 구현하기 편하다.

### 2. Eager Version
무방향 간선은 두개의 단방향 간선으로 표현될 수 있다.   
A-B : A->B, B->A  처럼 말이다.   
이 특징을 다음 특징( MST의 각 노드는 반드시 하나 이상의 다른 노드와 연결되어 있다)과 생각하면 Eager Prim Algorithm의 핵심을 알 수 있다.
__MST의 각 노드(단, 시작 노드는 제외)는 모두 하나의 incoming edge(자신으로 들어오는 간선, 최소가중치값을 가짐)으로 연결되어 있다.__ 
LAZY에서 해당 노드에 대해 모든간선을 추가하는데, 기존큐에 간선을 추가하는 대신 미리 테이블 {도착 노드이름: 간선}을 설정한 뒤에, 계속 해서 간선을 업데이트 해나가는 방식이다.  

https://www.youtube.com/watch?v=xq3ABa-px_g[참고]




